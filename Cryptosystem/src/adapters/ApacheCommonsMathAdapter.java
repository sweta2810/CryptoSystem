package adapters;

import java.util.Random;

import keyGen.ParamGen;


import org.apache.commons.math3.distribution.NormalDistribution;

import org.apache.commons.math3.exception.NotStrictlyPositiveException;
/**
 * 
 * @author Aaron Curtis and Nishant Rathore
 *
 */

public class ApacheCommonsMathAdapter implements StatisticsAdapter {

	NormalDistribution nd = null;
	ParamGen pGen = new ParamGen();
	@Override
	public double sample(){
		if (nd == null){
			nd = new NormalDistribution(0.0,pGen.getBeta());
			
		}
		
		Double notQuiteSample = nd.sample();
		
		
		
		double q = pGen.getModulus();
		double sample = Math.round(notQuiteSample*q);
		
		
		return sample%q;
	}

	@Override
	public double[][] generateErrorMatrix() {
		//potential issue with casting here
		ParamGen pGen = new ParamGen();
		double dimentionality = pGen.generateDimentionality();
		double[][] errorMatrix = new double[(int) dimentionality][(int) dimentionality];
		for (int x=0;x<(int)dimentionality;x++){
			for (int y=0;y<(int)dimentionality;y++){
				errorMatrix[x][y] = this.sample();
			}
		}
		return errorMatrix;
	}
	
	/**
	 * Generates a uniformly random securityParameterXdimentionality matrix of the given modulus.
	 * @param modulus the modulus of the interger number system from which the random values will be drawn.
	 * @param securityParameter the security parameter chosen by the user for the system.
	 * @param dimentionality the size of the columns of the output matrix. Generated by the ParamGen class.
	 * @return ranMatrix matrix with securityParameter rows of dimentionality size and random BigInteger components.
	 */
	@Override
	public double[][] generateRandomMatrix(){
		ParamGen pGen = new ParamGen();
		double modulus = pGen.getModulus();
		double securityParameter = pGen.getSecurityParameter(); 
		double dimentionality = pGen.generateDimentionality();
		
		Random ran = new Random();
		//potential loss of accuracy here, due to converting from BigInteger but matrix dimensions are small compared to dimensionality size, so as long as the security parameter is small... we'll need to put in proper size checking later
		double[][] ranMatrix =  new double[(int)securityParameter][(int)dimentionality];
		for (int x=0;x<securityParameter;x++){
			for(int y=0;y<(int)dimentionality;y++){
				//is 256 the number of bits we want??? Do we need more?
				double b = ran.nextInt();
				ranMatrix[x][y] = b%modulus;
			}
		}
		return (ranMatrix);		
	}

}
