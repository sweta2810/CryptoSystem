package encrypt;

import java.math.BigInteger;
import java.util.Random;

import keyGen.ParamGen;

public class MatrixGen {

	/**
	 * Generates a error matrix sampled from the distribution in the lwe-bgn paper.
	 * @return
	 */
	public BigInteger[][] generateErrorMatrix(){
		return null;		
	}
	
	/**
	 * Generates a uniformly random securityParameterXdimentionality matrix of the given modulus.
	 * @param modulus the modulus of the interger number system from which the random values will be drawn.
	 * @param securityParameter the security parameter chosen by the user for the system.
	 * @param dimentionality the size of the columns of the output matrix. Generated by the ParamGen class.
	 * @return ranMatrix matrix with securityParameter rows of dimentionality size and random BigInteger components.
	 */
	public double[][] generateRandomMatrix(){
		ParamGen pGen = new ParamGen();
		double modulus = pGen.getModulus();
		double securityParameter = pGen.getSecurityParameter(); 
		double dimentionality = pGen.generateDimentionality();
		
		Random ran = new Random();
		//potential loss of accuracy here, due to converting from BigInteger but matrix dimensions are small compared to dimensionality size, so as long as the security parameter is small... we'll need to put in proper size checking later
		double[][] ranMatrix =  new double[(int)securityParameter][(int)dimentionality];
		for (int x=0;x<securityParameter;x++){
			for(int y=0;y<(int)dimentionality;y++){
				//is 256 the number of bits we want??? Do we need more?
				double b = ran.nextDouble();
				ranMatrix[x][y] = b%modulus;
			}
		}
		return ranMatrix;		
	}
	
}
